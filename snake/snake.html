<canvas id="c" width="300" height="300">//это html объект над ним не надо задумываться

</canvas>

<script>//сегмент кода в html ограничивается '<script>'-тэгом , язык по defaultу javascript

    X=[];Y=[];//глобальные переменные для ячеек змейки - в X[i] лежит
    //x-овая координата i-ого куска змеи, то же для Y[i]

    k=j=0;//k- иксовая координата еды, j- y координата еды

    l=0;//логическая переменная которая понадобится для определения столкновения с хвостом

    n=0;//тут мы храним направление движения: типо 0-вправо 1-вниз 2-влево 3-вверх


    function g(){//функция которая помещает яблоко в рандомную точку
        with(Math){// конструсция with(..){} позволяет сократить код
            k=floor(random()*15);//тут было бы написано 'Math.floor(Math.random()*15)', но with сокращает код
            j=floor(random()*15)// Math.floor возвращает целую часть числа ( floor(1.5)==1 )
        }
        return 1//мы используем эту функцию в логическом выражении (сюда нужно будет вернутся чтобы понять)
    }


    onload=function onstart(){//объявление функции onstart, которая кладётся в функцию onload
    //onload вызывается браузером когда страница загружена

    c=document.querySelector('#c');// объявление глобальной переменной 'c' в которую мы кладём
    // объект 'canvas'. Над этим можно не задумываться - принимать как данное

    ctx=c.getContext`2d`;//у 'canvas' есть объект 'context' который именно позволяет что-то нарисовать

    X[0]=7;//задаём голову змейки
    Y[0]=7;// массивы в javascript автоматически расширяются и могут быть неполными
    // типо можно объявить массив так: ar=[]; ar[1000]=5; тогда массив сам расширится на
    //1000 элементов и все пустые элементы станут равны 'undefined'


    t=e=>{ctx.fillStyle=e};//создаём лямбда-функцию ( это типо более короткий синтаксис для той же функции 'function' )
    //  эта функция возьмёт элемент 'e' с input-а и положит его в ctx.fillStyle
    // по сути мы меняем цвет ручки


    onkeydown=e=>{if(e.keyCode==37)n=2;if(e.keyCode==38)n=3;if(e.keyCode==39)n=0;if(e.keyCode==40)n=1};
    //onkeydown это тоже одна из встроенных функций- она вызывается каждый раз после нажатия кнопки
    //нам она передаёт объект (который мы читаем на входе как 'e'), который содержит много ненужной информации
    //мы берём от него только поле keyCode - оно позволяет понять какая кнопка была нажата и в соответствии с ним меняем
    //направление движения змейки (37,38,39,40 - стрелочки)

    //перед следующей строкой нужна моральная подготовка:
    //функция window.setInterval сокращённо может быть записана как просто setInterval
    //на вход она получает два значения: какую-то функцию и число милисекунд
    //каждые n-милисекунд будет вызываться данная функция(каждый раз с начала).Может возникнуть
    //параллельность. setInterval возвращает адрес интервала чтобы его можно было "kill-нуть" - прекратить это вызывание
    //указанной функции

    I=setInterval( e=>{// в переменную I записываем адрес интервала. Внутри сразу создаём
        //анонимную функцию с помощью лямбда функции ( можно было бы setInterval( function(...){...},150) )

        //следующие строки кода будут вызываться каждые 150 милисекунд
        t`black`;//цвет пера установить на чёрный (в функцию которая на вход принимает строку можно вот так
        // запихнуть её типо :  t('black')===t`black`    )

        ctx.fillRect(0,0,300,300);//вызываем встроенную функцию графического контекста fillRect(x,y,width,height)
        //она закрашивает текущим цветом прямоугольник ну вроде понятно какой

        t`white`;//цвет пера белый (мне нравятся монохромные картинки, так можно было бы цвет еды делать красным)

        ctx.fillRect(k*20,j*20,20,20);//рисуем еду на её координатах. Все элементы графики отсюда и дальше - квадарты 20x20


        for(i=X.length;i>0;i--){//тут очень много вещей происходит:
            //мы проходим массив с конца и как бы сдвигаем каждый элемент на одну ячейку назад
            //кстати, array.length - встроенный метод и возвращает интересную величину ( {1,2,3,6}.length==4 )

            X[i]=X[i-1];//происходит копирование элементов со смещением в 1
            Y[i]=Y[i-1];//это наша змейка оставляет после себя след

            ctx.fillRect(X[i]*20,Y[i]*20,20,20);//рисуем часть змейки
        }//ты заметил, что после этого длина змейки увеличивается на 1? мы используем это позже

        if(!n)X[0]++;//в зависимости от направления
        if(n==1)Y[0]++;//движения изменяем координаты по сравнению с
        if(n==2)X[0]--;//предыдущими
        if(n==3)Y[0]--;

        x=X[0];y=Y[0];//тут чисто удобнее переобозначить
        //x и y - временные переменные, обозначают координаты головки

        ctx.fillRect(x*20,y*20,20,20);//рисуем головку змейки


        //здесь произойдёт очень много всего - проверка на съедание
        (x==k&&y==j&&g())||(X.length--&&Y.length--);//первая часть условия (до or-а)
        //делает следующее - && когда встречает 0 автоматически выставляет значение всего выражения в 0
        //и скипает все последующие инструкции, соответственно g() выполнится только если x==k и y==j
        //как мы помним g() возвращает 1 ВСЕГДА. Поэтому если змейка растёт, то первая скобка 1 -
        //тогда в выражении 1||(...) вторая часть даже не считается - значение выражения всё равно будет 1
        //А вторая часть содержит array.length-- . до этого момента array.length хотя бы 2 (подумай сам почему не бывает змейки из 0 ячеек)
        //Поэтому оба выражения a.length-- вычисляются, а эти выражения просто "обрезают" массив - мы вручную укорачиваем его на 1 лишний элемент

        //изначально l==0 (мы ущё ни разу не сталкивались)
        for(i=1;i<X.length;i++)x==X[i]&&y==Y[i]&&l++;//эта строчка кода увеличит l только в случае если головка совпала с каким-то хвостом

        //если l!=0 (было столкновение) или мы вышли за границы игрового поля
        (l||x<0||y<0||x>14||y>14)&&clearInterval(I);//стираем интервал на который указывает I
        //если всё зорошо ждём следующего вызова

    },150);//150 мс


    }//

</script>